# -*- coding: utf-8 -*-
"""irs_data

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1uPT_N3tc_-1JnwddHGCj3qD-OPid0wT1
"""

import pandas as pd
import numpy as np
import requests
import matplotlib.pyplot as plt
import json

df_irs_totals = pd.DataFrame()
for year in range(2015, 2021):
    url = f'https://us-central1-taxfiling-aggregation.cloudfunctions.net/filings-summary?parm_name=VW_tab_{year}_total_returns_and_amounts'
    response = requests.get(url)
    data = response.json()
    df = pd.DataFrame(data)
    # df['year'] = year
    df_irs_totals = pd.concat([df_irs_totals, df], ignore_index=True)
df_irs_totals.rename(columns=lambda x: x.strip(), inplace=True)


def tax_attribute_dictionary(output="dataframe"):
    url_attr = 'https://us-central1-taxfiling-aggregation.cloudfunctions.net/filings-summary?parm_name=tab_irs_data_extraction_field_names'
    response = requests.get(url_attr)
    responsedata = response.json()
    data_attr = pd.DataFrame(responsedata)
    if output == "dataframe":
        df_attr = pd.DataFrame(data_attr)
        return df_attr
    elif output == "json":
        return responsedata


def state_code_dictionary(output="dataframe"):
    url = f'https://us-central1-taxfiling-aggregation.cloudfunctions.net/filings-summary?parm_name=tab_State_code'
    response = requests.get(url)
    responsedata = response.json()
    data = pd.DataFrame(responsedata)
    state_dict = {}
    for index, row in data.iterrows():
        state_code = row['state_code']
        state_name = row['state_name']
        state_dict[state_code] = state_name
    return (state_dict)


state_codes = state_code_dictionary()


def income_level_dictionary(output="dataframe"):
    url = f'https://us-central1-taxfiling-aggregation.cloudfunctions.net/filings-summary?parm_name=tab_income_level_mapping'
    response = requests.get(url)
    responsedata = response.json()
    data = pd.DataFrame(responsedata)
    if output == "dataframe":
        df = pd.DataFrame(data)
        income_dict = {}
        for index, row in df.iterrows():
            income_level = row['income_level']
            description = row['income_level_description']
            income_dict[income_level] = description
        return (income_dict)
    elif output == "json":
        return responsedata


income_level_mapping = income_level_dictionary()

extraction_attributes = tax_attribute_dictionary()['variable'].tolist()


def get_state_tax_year_income_filings(state_code: str, year: int, income_level: int, *categories: str) -> pd.DataFrame:
    '''Takes in at least three parameters: a state code, the year, the income level, and any number of categories. It will return a dataframe of the sums for each of those categories for the desired income levels, states, and years.'''
    for category in categories:
        if list(categories).count(category) > 1:
            return "Please enter distinct categories."
    for category in categories:
        if category not in list(extraction_attributes):
            return "Please choose a valid category."
    for category in categories:
        if category in ['year', 'zipcode', 'income_level', 'statefips', 'state_code']:
            return "Please choose a category that is not 'year', 'state_code', 'zipcode', or 'income_level', or 'statefips'."
    if year not in [2015, 2016, 2017, 2018, 2019, 2020, 0]:
        return "Please enter a valid year, between 2015-2020 or 0."
    if income_level not in [0, 1, 2, 3, 4, 5, 6]:
        return "Please enter a valid income level (0-6)."
    if year != 0:
        df_filtered_year = df_irs_totals[(df_irs_totals['year'] == year)]
    else:
        df_filtered_year = df_irs_totals.copy()
    if (state_code not in list(state_codes.keys())) and state_code != 'ALL':
        return "Please enter a valid state code."
    if (state_code != 'ALL'):
        df_filtered_yearstate = df_filtered_year.loc[df_filtered_year['state_code'] == state_code]
    else:
        df_filtered_yearstate = df_filtered_year.copy()
    if (income_level != 0):
        df_filtered_yearstateincome = df_filtered_yearstate[(
            df_filtered_yearstate['income_level'] == income_level)]
    else:
        df_filtered_yearstateincome = df_filtered_yearstate.copy()
    if len(categories) == 0:
        df_final = df_filtered_yearstateincome.copy()
    else:
        extraction_list = ['year', 'income_level', 'statefips', 'state_code']
        extraction_list += list(categories)
        df_final = df_filtered_yearstateincome[list(extraction_list)].copy()
    df_final = df_final.reset_index(drop=True)
    df_final['income_level'] = df_final['income_level'].replace(
        income_level_mapping)
    return (df_final)


def get_totals_for_state_year_income(state_code: str, year: int, income_level: int, *categories: str) -> pd.DataFrame:
    '''Takes in at least three parameters: a state code, the year, the income level, and any number of categories. It will return a dataframe of the sums for each of those categories, for the specific income level, given the year and state code.'''
    for category in categories:
        if category not in list(extraction_attributes):
            return "Please choose a valid category."
    if state_code not in list(state_codes.keys()):
        return "Please enter a valid state code."
    if year not in [2015, 2016, 2017, 2018, 2019, 2020, 0]:
        return "Please enter a valid year, between 2015-2020."
    for category in categories:
        if category in ['year', 'zipcode', 'income_level', 'statefips', 'state_code']:
            return "Please choose a category that is not 'year', 'state_code', 'zipcode', or 'income_level', or 'statefips'."
    if income_level not in [1, 2, 3, 4, 5, 6]:
        return "Please enter a valid income level (1-6)."
    for category in categories:
        if list(categories).count(category) > 1:
            return "Please enter distinct categories."

    df_filtered_testing = df_irs_totals[(df_irs_totals['year'] == year)]
    for category in categories:
        if df_filtered_testing[category].isna().all():
            return "Please choose a valid category that is in the year you entered."
    df_filtered = df_irs_totals[(df_irs_totals['year'] == year) & (
        df_irs_totals['state_code'] == state_code) & (df_irs_totals['income_level'] == income_level)]
    df_final = pd.DataFrame()
    if len(categories) == 0:
        columns_to_exclude = ['year', 'zipcode',
                              'income_level', 'statefips', 'state_code']
        categories = [
            column for column in df_filtered.columns if column not in columns_to_exclude]
        df_final = df_filtered.copy()
    else:
        df_final = df_filtered[list(categories)].copy()

    for category in categories:
        number_sum = df_final[category].sum()
        df_final[category] = number_sum
    df_final = df_final.reset_index(drop=True)
    df_final['state'] = state_code
    df_final['year'] = year
    df_final['income_level'] = income_level

    return df_final


def get_totals_for_state_year_income(state_code: str, year: int, income_level: int, *categories: str) -> pd.DataFrame:
    '''Takes in at least three parameters: a state code, the year, the income level, and any number of categories. It will return a dataframe of the sums for each of those categories, for the specific income level, given the year and state code.'''

    # Helper function to filter the DataFrame based on the state and year
    def filter_dataframe(state_code, year):
        if state_code == "ALL" and year == 0:
            df_filtered = df_irs_totals.copy()
        elif state_code == "ALL":
            df_filtered = df_irs_totals[df_irs_totals['year'] == year].copy()
        elif year == 0:
            df_filtered = df_irs_totals[df_irs_totals['state_code'] == state_code].copy(
            )
        else:
            df_filtered = df_irs_totals[(df_irs_totals['year'] == year) & (
                df_irs_totals['state_code'] == state_code)].copy()
        return df_filtered

    if income_level == 0:
        df_filtered = filter_dataframe(state_code, year)
    else:
        df_filtered = filter_dataframe(state_code, year)
        df_filtered = df_filtered[df_filtered['income_level'] == income_level]

    for category in categories:
        if category not in list(df_irs_totals.columns):
            return "Please choose a valid category."

    if state_code != "ALL" and state_code not in list(state_codes.keys()):
        return "Please enter a valid state code."

    if year != 0 and year not in [2015, 2016, 2017, 2018, 2019, 2020]:
        return "Please enter a valid year, between 2015-2020."

    for category in categories:
        if category in ['year', 'zipcode', 'income_level', 'statefips', 'state_code']:
            return "Please choose a category that is not 'year', 'state_code', 'zipcode', or 'income_level', or 'statefips'."

    if income_level not in [0, 1, 2, 3, 4, 5, 6]:
        return "Please enter a valid income level (0-6)."

    for category in categories:
        if list(categories).count(category) > 1:
            return "Please enter distinct categories."

    if df_filtered.empty:
        return "No data available for the selected criteria."

    df_final = pd.DataFrame()
    if len(categories) == 0:
        columns_to_exclude = ['year', 'zipcode',
                              'income_level', 'statefips', 'state_code']
        categories = [
            column for column in df_filtered.columns if column not in columns_to_exclude]
        df_final = df_filtered.copy()
    else:
        df_final = df_filtered[list(categories)].copy()

    for category in categories:
        number_sum = df_final[category].sum()
        df_final[category] = number_sum

    df_final = df_final.reset_index(drop=True)

    if state_code == "ALL":
        df_final['state'] = "All States"
        df_final = df_final.head(1)
    else:
        df_final['state'] = state_code

    if year == 0:
        df_final['year'] = "All Years"
        df_final = df_final.head(1)
    else:
        df_final['year'] = year

    df_final['income_level'] = income_level

    return df_final


def get_totals_for_state_year(state_code: int, year: int, *categories: str) -> pd.DataFrame:
    '''Takes in at least two parameters: a state code and the year, and any number of categories. It will return a dataframe of the sums for each of those categories, across all income levels, given the year and state code.'''
    for category in categories:
        if category not in list(extraction_attributes):
            return "Please choose a valid category."
    if state_code not in list(state_codes.keys()):
        return "Please enter a valid state code."
    if year not in [2015, 2016, 2017, 2018, 2019, 2020, 9999]:
        return "Please enter a valid year, between 2015-2020."
    for category in categories:
        if category in ['year', 'zipcode', 'income_level', 'statefips', 'state_code']:
            return "Please choose a category that is not 'year', 'state_code', 'zipcode', or 'income_level', or 'statefips'."
    for category in categories:
        if list(categories).count(category) > 1:
            return "Please enter distinct categories."

    df_filtered_testing = df_irs_totals[(df_irs_totals['year'] == year)]
    for category in categories:
        if df_filtered_testing[category].isna().all():
            return "Please choose a valid category that is in the year you entered."

    df_filtered = df_irs_totals[(df_irs_totals['year'] == year) & (
        df_irs_totals['state_code'] == state_code)]
    if len(categories) == 0:
        columns_to_exclude = ['year', 'zipcode',
                              'income_level', 'statefips', 'state_code']
        categories = [
            column for column in df_filtered.columns if column not in columns_to_exclude]
        df_final = df_filtered.copy()
    else:
        df_final = df_filtered[list(categories)].copy()
    df_final['year'] = year
    df_final['state_code'] = state_code
    for category in categories:
        number_sum = df_final[category].sum()
        df_final[category] = number_sum
    df_final = df_final.reset_index(drop=True)
    df_final = df_final.head(1)
    df_final['income_level'] = '0'
    return df_final


def get_totals_for_year(year: int, *categories: str) -> pd.DataFrame:
    '''Takes in at least one parameter: the year, and any number of categories. It will return a dataframe of the sums for each of those categories, across all income levels and across all states (the total for the entire year).'''
    for category in categories:
        if category not in list(extraction_attributes):
            return "Please choose a valid category."
    if year not in [2015, 2016, 2017, 2018, 2019, 2020]:
        return "Please enter a valid year, between 2015-2020."
    for category in categories:
        if category in ['year', 'zipcode', 'income_level', 'statefips', 'state_code']:
            return "Please choose a category that is not 'year', 'state_code', 'zipcode', or 'income_level', or 'statefips'."
    for category in categories:
        if list(categories).count(category) > 1:
            return "Please enter distinct categories."
    df_filtered = df_irs_totals[(df_irs_totals['year'] == year)]
    for category in categories:
        if df_filtered[category].isna().all():
            return "Please choose a valid category that is in the year you entered."

    if len(categories) == 0:
        columns_to_exclude = ['year', 'zipcode',
                              'income_level', 'statefips', 'state_code']
        categories = [
            column for column in df_filtered.columns if column not in columns_to_exclude]

    df_final = pd.DataFrame(
        {category: [df_filtered[category].sum()] for category in categories})
    df_final.rename(
        columns={category: f'{category}' for category in categories}, inplace=True)
    df_final = df_final.reset_index(drop=True)
    df_final.dropna(axis=1, how='all', inplace=True)
    df_final = df_final.head(1)
    df_final['year'] = year
    return df_final


def get_totals_for_year_by_state(year: int, *categories: str) -> pd.DataFrame:
    '''Takes in at least one parameter: the year, and any number of categories. It will return a dataframe of the sums for each of those categories across all income levels, for each state, given the year.'''
    for category in categories:
        if category not in list(extraction_attributes):
            return "Please choose a valid category."
    if year not in [2015, 2016, 2017, 2018, 2019, 2020]:
        return "Please enter a valid year, between 2015-2020."
    for category in categories:
        if category in ['year', 'zipcode', 'income_level', 'statefips', 'state_code']:
            return "Please choose a category that is not 'year', 'state_code', 'zipcode', or 'income_level', or 'statefips'."
    for category in categories:
        if list(categories).count(category) > 1:
            return "Please enter distinct categories."

    df_filtered = df_irs_totals[df_irs_totals['year'] == year]

    for category in categories:
        if df_filtered[category].isna().all():
            return "Please choose a valid category that is in the year you entered."

    if len(categories) == 0:
        columns_to_exclude = ['year', 'zipcode', 'income_level', 'statefips']
        categories = [
            column for column in df_filtered.columns if column not in columns_to_exclude]
    else:
        categories = ['state_code'] + list(categories)

    df_final = pd.DataFrame(columns=['state', 'year'] + list(categories))
    states = df_filtered['state_code'].unique()
    data_to_concat = []
    for state in states:
        df_filtered_state = df_filtered[df_filtered['state_code'] == state]
        totals_dict = {'state': state, 'year': year}
        for category in categories:
            number_sum = df_filtered_state[category].sum()
            totals_dict[category] = number_sum

        data_to_concat.append(totals_dict)

    df_data_to_concat = pd.DataFrame(data_to_concat)
    df_final = pd.concat([df_final, df_data_to_concat], ignore_index=True)
    df_final.drop(columns='state_code', inplace=True)
    return df_final


def income_distribution_state_year(state_code: int, year: int, output_format: str = 'dataframe'):
    '''Takes in at least two or three parameters: the state code, the year, and optionally the type of visualization. It will return a visualization of the distribution of the number of returns across the different income levels, for that state and year. The default "visualization" is a dataframe.'''
    if state_code not in list(state_codes.keys()):
        return "Please enter a valid state code."
    if year not in [2015, 2016, 2017, 2018, 2019, 2020]:
        return "Please enter a valid year, between 2015-2020."
    if output_format not in ['pie_chart', 'graph', 'dataframe']:
        return "Please enter a valid output format: 'pie_chart', 'graph', or 'dataframe'."

    df_filtered = df_irs_totals[(df_irs_totals['year'] == year) & (
        df_irs_totals['state_code'] == state_code) & (df_irs_totals['zipcode'] == 0)]
    df_final = df_filtered[['n_ret', 'income_level']].copy()
    df_final = df_final.reset_index(drop=True)
    total = df_final['n_ret'].sum()
    for index, value in df_final.iterrows():
        percentage = ((df_final.loc[index, 'n_ret'] / total) * 100).round(2)
        df_final.loc[index, 'n_ret'] = f'{percentage}%'
    if output_format == 'dataframe':
        return df_final
    elif output_format == 'pie_chart':
        labels = df_final['income_level']
        percentages = df_final['n_ret'].str.rstrip('%').astype(float)
        fig, ax = plt.subplots()
        plt.pie(percentages, labels=labels, autopct='%2.2f%%', startangle=90,
                textprops={'color': 'white', 'fontsize': 8}, pctdistance=0.8)
        ax.axis('equal')
        ax.set_title('Pie Chart: Income Distribution by Category')
        ax.legend(loc='center left', bbox_to_anchor=(
            1, 0.5), title='Income Category')
        plt.subplots_adjust(right=0.65)
        plt.show()
    elif output_format == 'graph':
        x = df_final['income_level']
        y = df_final['n_ret'].str.rstrip('%').astype(float)
        plt.bar(x, y)
        plt.xlabel('Income Category')
        plt.ylabel('Percentage')
        plt.title('Income Distribution by Category')
        plt.xticks(rotation=0)
        plt.show()
    else:
        print("Invalid output format. Please choose 'dataframe', 'pie_chart', or 'graph'.")


def income_all_distribution_pct_change_year(state_code: str, year1: int, year2: int) -> pd.DataFrame:
    '''Takes in three parameters: the state code and two years. It will return a dataframe of the percent change for the number of returns for each income level from the older year to the newer year, given the state.'''
    if state_code not in list(state_codes.keys()):
        return "Please enter a valid state code."
    if (year1 not in [2015, 2016, 2017, 2018, 2019, 2020]) or (year2 not in [2015, 2016, 2017, 2018, 2019, 2020]):
        return "Please enter a valid year, between 2015-2020."

    income_levels = range(1, 7)
    results = []
    for income_level in income_levels:
        df_filtered = df_irs_totals[(df_irs_totals['state_code'] == state_code) & (
            df_irs_totals['income_level'] == income_level) & (df_irs_totals['zipcode'] == 0)]
        df_filtered_year1 = df_filtered[df_filtered['year'] == year1].reset_index(
            drop=True)
        df_filtered_year2 = df_filtered[df_filtered['year'] == year2].reset_index(
            drop=True)

        year1_value = df_filtered_year1['n_ret'].iloc[0]
        year2_value = df_filtered_year2['n_ret'].iloc[0]

        if year1 < year2:
            percent_change = (
                ((year2_value - year1_value) / year1_value) * 100).round(2)
        elif year1 > year2:
            percent_change = (
                ((year1_value - year2_value) / year2_value) * 100).round(2)
        else:
            return "years entered are the same. Please provide different years."

        results.append({'Income Level': income_level,
                       'Percent Change': f'{percent_change}%'})

    df_results = pd.DataFrame(results)
    return df_results


def income_type_distribution_pct_change_every_consec_year(state_code: str, income_level: int) -> pd.DataFrame:
    '''Takes in two parameters: the state code and an income level. It will return a dataframe of the percent change for the number of returns for the specific income level for each pair of consecutive years, for the state (or all states).'''
    if state_code not in (list(state_codes.keys())+['ALL']):
        return "Please enter a valid state code."
    if income_level not in [1, 2, 3, 4, 5, 6]:
        return "Please enter a valid income level (1-6)."
    if state_code == 'ALL':
        df_filtered = df_irs_totals[(df_irs_totals['income_level'] == income_level) & (
            df_irs_totals['zipcode'] == 0)]
        df_filtered.reset_index(drop=True, inplace=True)
        columns = ['income_level', 'state_code', '2015 to 2016',
                   '2016 to 2017', '2017 to 2018', '2018 to 2019', '2019 to 2020']
        df = pd.DataFrame(columns=columns)
        for index, state_code in enumerate(list(state_codes.keys())):
            n_ret_income_level = []
            for i in range(2015, 2021):
                df_filtered_year = df_filtered[(df_filtered['year'] == i) & (
                    df_filtered['state_code'] == state_code)]
                num_ret = df_filtered_year['n_ret'].iloc[0]
                n_ret_income_level.append(num_ret)
            df.loc[index, 'income_level'] = income_level
            df.loc[index, 'state_code'] = state_code
            for i in range(2015, 2020):
                df.loc[index,
                       f'{i} to {i+1}'] = f'{(((n_ret_income_level[i-2014] - n_ret_income_level[i-2015])/n_ret_income_level[i-2015])*100).round(2)}%'
        return df
    else:
        df_filtered = df_irs_totals[(df_irs_totals['state_code'] == state_code) & (
            df_irs_totals['income_level'] == income_level) & (df_irs_totals['zipcode'] == 0)]
        df_filtered.reset_index(drop=True, inplace=True)
        n_ret_income_level = []
        for i in range(2015, 2021):
            df_filtered_year = df_filtered[df_filtered['year'] == i]
            num_ret = df_filtered_year['n_ret'].iloc[0]
            n_ret_income_level.append(num_ret)
        columns = ['income_level']
        df = pd.DataFrame(columns=columns)
        df.loc[0, 'income_level'] = income_level
        df['state'] = state_code
        for i in range(2015, 2020):
            df[f'{i} to {i+1}'] = f'{(((n_ret_income_level[i-2014] - n_ret_income_level[i-2015])/n_ret_income_level[i-2015])*100).round(2)}%'
        return df


def return_type_distribution_pct_change_year(state_code: str, category: str, year1: int, year2: int) -> str:
    '''Takes in four parameters: the state code, a category, and two years. It will return the percent change for the value of that category (the sum across all income levels) from the older year to the newer year, given the state.'''
    if category not in list(extraction_attributes):
        return "Please choose a valid category."
    if state_code not in list(state_codes.keys()):
        return "Please enter a valid state code."
    if (year1 not in [2015, 2016, 2017, 2018, 2019, 2020]) or (year2 not in [2015, 2016, 2017, 2018, 2019, 2020]):
        return "Please enter a valid year, between 2015-2020."

    df_filtered_1 = df_irs_totals[(df_irs_totals['year'] == year1) & (
        df_irs_totals['state_code'] == state_code)]
    df_filtered_1 = df_filtered_1.reset_index(drop=True)
    df_filtered_2 = df_irs_totals[(df_irs_totals['year'] == year2) & (
        df_irs_totals['state_code'] == state_code)]
    df_filtered_2 = df_filtered_2.reset_index(drop=True)

    if df_filtered_1[category].isna().all():
        return "Please choose a valid category that is in the year you entered."
    if df_filtered_2[category].isna().all():
        return "Please choose a valid category that is in the year you entered."
    if category in df_filtered_1.columns and category in df_filtered_2.columns and category not in ['year', 'state_code', 'zipcode', 'income_level', 'statefips']:
        sum_1 = df_filtered_1[category].sum()
        sum_2 = df_filtered_2[category].sum()
        if year1 < year2:
            if sum_1 == 0:
                return 'Inf.'
            percent_change = (((sum_2 - sum_1) / sum_1) * 100).round(2)
            return f'The percent change for {category} from {year1} to {year2} is {percent_change}%'
        elif year1 > year2:
            if sum_2 == 0:
                return 'Inf.'
            percent_change = (((sum_1 - sum_2) / sum_2) * 100).round(2)
            return f'The percent change for {category} from {year2} to {year1} is {percent_change}%'
        else:
            return f'years entered are the same. Please provide different years.'
    elif category in ['year', 'state_code', 'zipcode', 'income_level', 'statefips']:
        return "Please choose a category that is not 'year', 'state_code', 'zipcode', 'statefips', or 'income_level'."
    else:
        return "Please choose a valid category that is in both of the years you entered."


def distribution_pct_change_year_df_all_income(year1: int, year2: int, *categories: str) -> pd.DataFrame:
    '''Takes in at least two parameters: two years and any number of categories. It will return a dataframe with the percent change for the value of that category (the sum across all income levels) from the older year to the newer year, for each state.'''
    for category in categories:
        if category not in list(extraction_attributes):
            return "Please choose a valid category."
    if year1 not in [2015, 2016, 2017, 2018, 2019, 2020] or year2 not in [2015, 2016, 2017, 2018, 2019, 2020]:
        return "Please enter a valid year, between 2015-2020."
    for category in categories:
        if category in ['year', 'zipcode', 'income_level', 'statefips', 'state_code']:
            return "Please choose a category that is not 'year', 'state_code', 'zipcode', or 'income_level', or 'statefips'."
    for category in categories:
        if list(categories).count(category) > 1:
            return "Please enter distinct categories."

    df_filtered_1 = df_irs_totals[df_irs_totals['year'] == year1].copy()
    df_filtered_1 = df_filtered_1.reset_index(drop=True)
    df_filtered_2 = df_irs_totals[df_irs_totals['year'] == year2].copy()
    df_filtered_2 = df_filtered_2.reset_index(drop=True)

    for category in categories:
        if df_filtered_1[category].isna().all() or df_filtered_2[category].isna().all():
            return "Please choose a valid category that is in both of the years you entered."

    for category in categories:
        if category not in df_filtered_1.columns:
            return "Please choose categories that are in both of the years you entered."
        if category not in df_filtered_2.columns:
            return "Please choose categories that are in both of the years you entered."

    for category in categories:
        if (category in df_filtered_1.columns and category not in df_filtered_2.columns) or (category in df_filtered_2.columns and category not in df_filtered_1.columns):
            return "Please choose categories that are in both of the years you entered."

    if len(categories) == 0:
        columns_to_exclude = ['year', 'zipcode', 'income_level', 'statefips']
        categories = [
            column for column in df_filtered_1.columns if column not in columns_to_exclude]
        df_last = pd.DataFrame(columns=categories)
    else:
        categories = ('state_code',) + categories
        df_final_1 = df_filtered_1[list(categories)].copy()
        df_final_2 = df_filtered_2[list(categories)].copy()
        df_last = pd.DataFrame(columns=categories)

    states = df_irs_totals['state_code'].unique()
    for index, state in enumerate(states):
        df_last.loc[index, 'state_code'] = state
        df_filtered_1_more = df_filtered_1[df_filtered_1['state_code'] == state]
        df_filtered_2_more = df_filtered_2[df_filtered_2['state_code'] == state]
        for category in categories[1:]:
            sum_1 = df_filtered_1_more[category].sum()
            sum_2 = df_filtered_2_more[category].sum()
            if year1 < year2:
                if sum_1 != 0:
                    percent_change = (((sum_2 - sum_1) / sum_1) * 100).round(2)
                    df_last.loc[index, category] = f'{percent_change}%'
                elif sum_1 == 0:
                    df_last.loc[index, category] = 'Inf.'
            elif year1 > year2:
                if sum_2 != 0:
                    percent_change = (((sum_1 - sum_2) / sum_2) * 100).round(2)
                    df_last.loc[index, category] = f'{percent_change}%'
                elif sum_2 == 0:
                    df_last.loc[index, category] = 'Inf.'
            else:
                return "Years entered are the same. Please enter different years."

    if year1 < year2:
        df_last['start_yr'] = year1
        df_last['end_yr'] = year2
    else:
        df_last['start_yr'] = year2
        df_last['end_yr'] = year1
    return df_last


def distribution_pct_change_year_df_by_income(state_code: str, income_level: int, year1: int, year2: int, *categories: str) -> pd.DataFrame:
    '''Takes in at least four parameters: a state code, an income level, two years, and any number of categories. It will return a dataframe with the percent change for the value of that category (for a specific income level) from the older year to the newer year, for the state (or all states).'''
    for category in categories:
        if category not in list(extraction_attributes):
            return "Please choose a valid category."
    if year1 not in [2015, 2016, 2017, 2018, 2019, 2020] or year2 not in [2015, 2016, 2017, 2018, 2019, 2020]:
        return "Please enter a valid year, between 2015-2020."
    for category in categories:
        if category in ['year', 'zipcode', 'income_level', 'statefips', 'state_code']:
            return "Please choose a category that is not 'year', 'state_code', 'zipcode', or 'income_level', or 'statefips'."
    for category in categories:
        if list(categories).count(category) > 1:
            return "Please enter distinct categories."
    if state_code not in (list(state_codes.keys())+['ALL']):
        return "Please enter a valid state code."
    if income_level not in [1, 2, 3, 4, 5, 6]:
        return "Please enter a valid income level (1-6)."

    df_filtered_1 = df_irs_totals[df_irs_totals['year'] == year1].copy()
    df_filtered_1 = df_filtered_1.reset_index(drop=True)
    df_filtered_2 = df_irs_totals[df_irs_totals['year'] == year2].copy()
    df_filtered_2 = df_filtered_2.reset_index(drop=True)

    for category in categories:
        if df_filtered_1[category].isna().all() or df_filtered_2[category].isna().all():
            return "Please choose a valid category that is in both of the years you entered."

    for category in categories:
        if category not in df_filtered_1.columns:
            return "Please choose categories that are in both of the years you entered."
        if category not in df_filtered_2.columns:
            return "Please choose categories that are in both of the years you entered."

    for category in categories:
        if (category in df_filtered_1.columns and category not in df_filtered_2.columns) or (category in df_filtered_2.columns and category not in df_filtered_1.columns):
            return "Please choose categories that are in both of the years you entered."

    if len(categories) == 0:
        columns_to_exclude = ['year', 'zipcode', 'income_level', 'statefips']
        categories = [
            column for column in df_filtered_1.columns if column not in columns_to_exclude]
        df_last = pd.DataFrame(columns=categories)
    else:
        categories = ('state_code',) + categories
        df_final_1 = df_filtered_1[list(categories)].copy()
        df_final_2 = df_filtered_2[list(categories)].copy()
        df_last = pd.DataFrame(columns=categories)

    states = df_irs_totals['state_code'].unique()
    for index, state in enumerate(states):
        df_last.loc[index, 'state_code'] = state
        df_filtered_1_more = df_filtered_1[(df_filtered_1['state_code'] == state) & (
            df_filtered_1['income_level'] == income_level)]
        df_filtered_2_more = df_filtered_2[(df_filtered_2['state_code'] == state) & (
            df_filtered_1['income_level'] == income_level)]
        for category in categories[1:]:
            sum_1 = df_filtered_1_more[category].sum()
            sum_2 = df_filtered_2_more[category].sum()
            if year1 < year2:
                if sum_1 != 0:
                    percent_change = (((sum_2 - sum_1) / sum_1) * 100).round(2)
                    df_last.loc[index, category] = f'{percent_change}%'
                elif sum_1 == 0:
                    df_last.loc[index, category] = 'Inf.'
            elif year1 > year2:
                if sum_2 != 0:
                    percent_change = (((sum_1 - sum_2) / sum_2) * 100).round(2)
                    df_last.loc[index, category] = f'{percent_change}%'
                elif sum_2 == 0:
                    df_last.loc[index, category] = 'Inf.'
            else:
                return "Years entered are the same. Please enter different years."

    if year1 < year2:
        df_last['start_yr'] = year1
        df_last['end_yr'] = year2
    else:
        df_last['start_yr'] = year2
        df_last['end_yr'] = year1

    df_last['income_level'] = income_level

    if state_code == "ALL":
        return df_last
    else:
        return df_last[df_last['state_code'] == state_code]


def filing_status_distribution_state_year_by_income(state_code: str, year: int, income_level: int, output_format: str = 'dataframe'):
    '''Takes in at least three or four parameters: the state code, the year, an income level, and optionally the type of visualization. It will return a visualization showing the distribution of the types of filing status returns out of the total number of returns for a specific income level. The default "visualization" is a dataframe.'''
    if state_code not in list(state_codes.keys()):
        return "Please enter a valid state code."
    if year not in [2015, 2016, 2017, 2018, 2019, 2020]:
        return "Please enter a valid year, between 2015-2020."
    if income_level not in [1, 2, 3, 4, 5, 6]:
        return "Please enter a valid income level (1-6)."
    if output_format not in ['pie_chart', 'graph', 'dataframe']:
        return "Please enter a valid output format: 'pie_chart', 'graph', or 'dataframe'."

    df_filtered = df_irs_totals[(df_irs_totals['year'] == year) & (df_irs_totals['state_code'] == state_code) & (
        df_irs_totals['zipcode'] == 0) & (df_irs_totals['income_level'] == income_level)]
    df_final = df_filtered[['income_level', 'n_ret',
                            'n_ret_single', 'n_ret_joint', 'n_ret_head_household']].copy()
    n1 = df_final['n_ret'].iloc[0]
    mars1 = df_final['n_ret_single'].iloc[0]
    mars2 = df_final['n_ret_joint'].iloc[0]
    mars4 = df_final['n_ret_head_household'].iloc[0]
    other = n1 - (mars1 + mars2 + mars4)
    mars1_pct = ((mars1/n1)*100).round(2)
    mars2_pct = ((mars2/n1)*100).round(2)
    mars4_pct = ((mars4/n1)*100).round(2)
    other_pct = (100 - (mars1_pct + mars2_pct + mars4_pct)).round(2)
    df_final = df_final.reset_index(drop=True)

    if output_format == 'dataframe':
        labels = ['Single', 'Joint', 'Head of Household', 'Other', 'Total']
        percentages = [f'{mars1_pct}%', f'{mars2_pct}%',
                       f'{mars4_pct}%', f'{other_pct}%', '100%']
        numbers = [mars1, mars2, mars4, other, n1]
        data = [
            {'Income Level': income_level,
                'Type': labels[i], 'Number': numbers[i], 'Pct': percentages[i]}
            for i in range(len(labels))
        ]
        df_last = pd.DataFrame(data)
        return df_last
    elif output_format == 'pie_chart':
        labels = ['Single', 'Joint', 'Head of Household', 'Other']
        percentages = [mars1_pct, mars2_pct, mars4_pct, other_pct]
        plt.pie(percentages, autopct='%2.2f%%', startangle=90, textprops={
                'color': 'black', 'fontsize': 8}, pctdistance=0.8)
        plt.axis('equal')
        plt.title('Filing Status Distribution')
        plt.legend(labels)
        plt.show()
    elif output_format == 'graph':
        x = ['Single', 'Joint', 'Head of Household', 'Other']
        y = [mars1_pct, mars2_pct, mars4_pct, other_pct]
        plt.bar(x, y)
        plt.xlabel('Filing Status')
        plt.ylabel('Percentage')
        plt.title('Filing Status Distribution')
        plt.xticks(rotation=0)
        plt.show()
    else:
        print("Invalid output format. Please choose 'dataframe', 'pie_chart', or 'graph'.")


def filing_status_distribution_state_year_all_income(state_code: str, year: int, output_format: str = 'dataframe'):
    '''Takes in at least three or four parameters: the state code, the year, and optionally the type of visualization. It will return a visualization showing the distribution of the types of filing status returns out of the total number of returns across all income level. The default "visualization" is a dataframe.'''
    if state_code not in list(state_codes.keys()):
        return "Please enter a valid state code."
    if year not in [2015, 2016, 2017, 2018, 2019, 2020]:
        return "Please enter a valid year, between 2015-2020."
    if output_format not in ['pie_chart', 'graph', 'dataframe']:
        return "Please enter a valid output format: 'pie_chart', 'graph', or 'dataframe'."

    df_filtered = df_irs_totals[(df_irs_totals['year'] == year) & (
        df_irs_totals['state_code'] == state_code) & (df_irs_totals['zipcode'] == 0)]
    df_med = df_filtered[['income_level', 'n_ret', 'n_ret_single',
                          'n_ret_joint', 'n_ret_head_household']].copy()
    n1 = df_med['n_ret'].sum()
    mars1 = df_med['n_ret_single'].sum()
    mars2 = df_med['n_ret_joint'].sum()
    mars4 = df_med['n_ret_head_household'].sum()
    other = n1 - (mars1 + mars2 + mars4)
    mars1_pct = ((mars1/n1)*100).round(2)
    mars2_pct = ((mars2/n1)*100).round(2)
    mars4_pct = ((mars4/n1)*100).round(2)
    other_pct = (100 - (mars1_pct + mars2_pct + mars4_pct)).round(2)
    df_med = df_med.reset_index(drop=True)
    df_final = pd.DataFrame(columns=['Filing Status', 'Percentage'])
    for i in range(0, 4):
        df_final['Percentage'] = [
            f'{mars1_pct}%', f'{mars2_pct}%', f'{mars4_pct}%', f'{other_pct}%']
        df_final['Filing Status'] = [mars1, mars2, mars4, other]
    if output_format == 'dataframe':
        labels = ['Single', 'Joint', 'Head of Household', 'Other', 'Total']
        percentages = [f'{mars1_pct}%', f'{mars2_pct}%',
                       f'{mars4_pct}%', f'{other_pct}%', '100%']
        numbers = [mars1, mars2, mars4, other, n1]
        data = [
            {'Income Level': 'All',
                'Type': labels[i], 'Number': numbers[i], 'Pct': percentages[i]}
            for i in range(len(labels))
        ]
        df_last = pd.DataFrame(data)
        return df_last
    elif output_format == 'pie_chart':
        labels = ['Single', 'Joint', 'Head of Household', 'Other']
        percentages = [mars1_pct, mars2_pct, mars4_pct, other_pct]
        plt.pie(percentages, labels=labels, autopct='%2.2f%%', startangle=90,
                textprops={'color': 'black', 'fontsize': 8}, pctdistance=0.8)
        plt.axis('equal')
        plt.title('Filing Status Distribution')
        plt.legend(labels)
        plt.show()
    elif output_format == 'graph':
        x = ['Single', 'Joint', 'Head of Household', 'Other']
        y = [mars1_pct, mars2_pct, mars4_pct, other_pct]
        plt.bar(x, y)
        plt.xlabel('Filing Status')
        plt.ylabel('Percentage')
        plt.title('Filing Status Distribution')
        plt.xticks(rotation=0)
        plt.show()
